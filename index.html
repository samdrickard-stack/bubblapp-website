<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bubbl - Do Life Lighter</title>
    <meta name="description" content="Bubbl turns your tasks into floating bubbles. Speak them into existence, share with your people, and pop them when they're done. Available on iOS.">
    <meta name="theme-color" content="#FFFFFF">
    <meta property="og:title" content="Bubbl - Do Life Lighter">
    <meta property="og:description" content="Speak your tasks into bubbles, share with your people, and pop them when done. The to-do app that makes life admin lighter.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://bubblapp.com">
    <meta property="og:image" content="https://bubblapp.com/og-image.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --cyan: #00D4FF; --blue: #5B8DEF; --purple: #9B59B6; --magenta: #B829DD;
            --bg-deep: #FFFFFF; --bg: #F8FAFC;
            --bg-card: rgba(255,255,255,0.8); --bg-card-hover: rgba(255,255,255,0.95);
            --border: rgba(0,0,0,0.08); --border-hover: rgba(0,0,0,0.15);
            --text-primary: #1E293B; --text-secondary: #64748B; --text-tertiary: #94A3B8;
            --gradient: linear-gradient(135deg, var(--cyan), var(--blue), var(--purple), var(--magenta));
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-deep); color: var(--text-primary);
            overflow-x: hidden; -webkit-font-smoothing: antialiased;
        }

        /* ═══════════════════════════════════════ */
        /* BUBBLE CANVAS                          */
        /* ═══════════════════════════════════════ */
        .bubble-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; overflow: hidden;
        }

        .glossy-bubble {
            position: absolute; border-radius: 50%;
            cursor: grab; user-select: none; -webkit-user-select: none;
            touch-action: none; z-index: 5;
            will-change: left, top, transform;
        }
        .glossy-bubble:active { cursor: grabbing; }
        .glossy-bubble.static-bubble { opacity: 0.8; filter: saturate(0.7); }

        .bubble-sphere {
            width: 100%; height: 100%; border-radius: 50%;
            position: relative; overflow: hidden;
        }
        .bubble-base { position: absolute; inset: 0; border-radius: 50%; }
        .bubble-highlight {
            position: absolute; width: 60%; height: 35%;
            top: 8%; left: 15%; border-radius: 50%;
            background: radial-gradient(ellipse, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.1) 50%, transparent 70%);
            transform: rotate(-15deg);
        }
        .bubble-highlight-2 {
            position: absolute; width: 20%; height: 15%;
            top: 15%; left: 22%; border-radius: 50%;
            background: radial-gradient(ellipse, rgba(255,255,255,0.6) 0%, transparent 70%);
        }
        .bubble-rim {
            position: absolute; inset: 0; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.15);
            background: radial-gradient(circle at 50% 100%, rgba(255,255,255,0.08) 0%, transparent 50%);
        }
        .bubble-glow {
            position: absolute; inset: -15%; border-radius: 50%;
            opacity: 0.3; filter: blur(15px); z-index: -1;
        }
        .bubble-label {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-weight: 600; text-align: center;
            line-height: 1.15; text-shadow: 0 1px 3px rgba(0,0,0,0.4);
            white-space: normal; overflow: hidden;
            width: 70%; max-height: 70%;
            word-wrap: break-word; overflow-wrap: break-word;
            display: flex; align-items: center; justify-content: center;
            pointer-events: none;
        }

        /* Progress ring for long-press */
        .pop-ring {
            position: absolute; top: -3px; left: -3px;
            pointer-events: none;
        }
        .pop-ring circle {
            fill: none; stroke: white; stroke-width: 3;
            stroke-linecap: round; transform: rotate(-90deg); transform-origin: center;
            transition: none;
        }

        /* Badges - positioned on bubble circumference matching iOS app */
        .bubble-badge {
            position: absolute; pointer-events: none;
            white-space: nowrap;
        }
        /* Due date: floats above bubble center, offset by radius + 8px */
        .badge-due {
            left: 50%; transform: translateX(-50%);
            padding: 3px 8px; border-radius: 10px;
            font-size: 9px; font-weight: 600; color: white;
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 0.5px solid rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 3px;
        }
        .badge-due.overdue { background: rgba(239,68,68,0.85); }
        .badge-due.today { background: rgba(184,41,221,0.85); }
        .badge-due.tomorrow { background: rgba(155,89,182,0.75); }
        .badge-due.future { background: rgba(91,141,239,0.65); }
        /* Checklist: bottom-right at 45° on circumference */
        .badge-checklist {
            background: rgba(0,0,0,0.5); color: white;
            font-size: 9px; font-weight: 700; border-radius: 10px;
            padding: 3px 6px;
            display: flex; align-items: center; gap: 3px;
        }
        .badge-checklist.complete { background: rgba(76,175,80,0.8); }
        /* Partner/Sender avatar: circle on circumference */
        .badge-avatar {
            border-radius: 50%;
            border: 1.5px solid rgba(255,255,255,0.8);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex; align-items: center; justify-content: center;
            font-weight: 600; color: white;
            background: linear-gradient(135deg, #00D4FF, #5B8DEF, #9B59B6);
            overflow: hidden;
        }

        /* Pop effects */
        .glossy-bubble.popping {
            animation: popBubble 0.35s ease forwards; pointer-events: none;
        }
        @keyframes popBubble {
            0% { transform: scale(1); opacity: 1; }
            15% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
        .pop-particle {
            position: absolute; border-radius: 50%; pointer-events: none;
            animation: particleFly 0.6s ease-out forwards;
        }
        @keyframes particleFly {
            0% { transform: translate(0,0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        .pop-sparkle {
            position: absolute; width: 4px; height: 4px; border-radius: 50%;
            background: #5B8DEF; pointer-events: none;
            animation: sparkleFly 0.5s ease-out forwards;
        }
        @keyframes sparkleFly {
            0% { transform: translate(0,0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        .pop-ripple {
            position: absolute; border-radius: 50%;
            border: 2px solid rgba(91,141,239,0.4); pointer-events: none;
            animation: rippleExpand 0.6s ease-out forwards;
        }
        @keyframes rippleExpand {
            0% { transform: scale(0.5); opacity: 0.6; }
            100% { transform: scale(3); opacity: 0; }
        }

        /* Background bubbles */
        .bubbles-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0; overflow: hidden;
        }
        .bubble-particle-bg {
            position: absolute; border-radius: 50%; opacity: 0;
            animation: floatBg linear infinite;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        @keyframes floatBg {
            0% { transform: translateY(100vh) translateX(0) scale(0); opacity: 0; }
            10% { opacity: 1; } 90% { opacity: 1; }
            100% { transform: translateY(-10vh) translateX(var(--drift)) scale(1); opacity: 0; }
        }

        /* ═══════════════════════════════════════ */
        /* NAV                                    */
        /* ═══════════════════════════════════════ */
        nav {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            padding: 20px 40px; display: flex; align-items: center; justify-content: space-between;
            background: rgba(255,255,255,0.85);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
        }
        .nav-logo {
            font-size: 24px; font-weight: 800;
            background: var(--gradient); -webkit-background-clip: text;
            -webkit-text-fill-color: transparent; background-clip: text;
        }
        .nav-links { display: flex; gap: 32px; align-items: center; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 14px; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text-primary); }
        .nav-cta {
            padding: 10px 24px; background: var(--gradient); border-radius: 50px;
            color: white !important; font-weight: 600 !important; -webkit-text-fill-color: white !important;
            transition: transform 0.2s, box-shadow 0.2s !important;
        }
        .nav-cta:hover { transform: translateY(-1px); box-shadow: 0 8px 30px rgba(91,141,239,0.3); }

        /* Mobile hamburger */
        .nav-hamburger {
            display: none; width: 28px; height: 20px; cursor: pointer;
            flex-direction: column; justify-content: space-between; position: relative; z-index: 110;
        }
        .nav-hamburger span {
            display: block; width: 100%; height: 2px; background: var(--text-primary);
            border-radius: 2px; transition: all 0.3s;
        }
        .nav-hamburger.open span:nth-child(1) { transform: rotate(45deg) translate(6px, 6px); }
        .nav-hamburger.open span:nth-child(2) { opacity: 0; }
        .nav-hamburger.open span:nth-child(3) { transform: rotate(-45deg) translate(6px, -6px); }
        .mobile-menu {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.97); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            z-index: 99; flex-direction: column; align-items: center; justify-content: center; gap: 32px;
        }
        .mobile-menu.open { display: flex; }
        .mobile-menu a {
            font-size: 24px; font-weight: 600; color: var(--text-primary);
            text-decoration: none; transition: color 0.2s;
        }
        .mobile-menu a:hover { color: var(--blue); }
        .mobile-menu .nav-cta {
            font-size: 18px; padding: 14px 36px;
        }

        /* ═══════════════════════════════════════ */
        /* HERO                                   */
        /* ═══════════════════════════════════════ */
        .hero {
            position: relative; min-height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 100px 24px 48px; z-index: 1;
        }
        .hero-glow {
            position: absolute; width: 700px; height: 700px; border-radius: 50%;
            background: radial-gradient(circle, rgba(91,141,239,0.08) 0%, rgba(155,89,182,0.04) 40%, transparent 70%);
            top: 50%; left: 50%; transform: translate(-50%,-50%);
            pointer-events: none; animation: pulseGlow 4s ease-in-out infinite;
        }
        @keyframes pulseGlow {
            0%, 100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%,-50%) scale(1.15); opacity: 0.6; }
        }
        .hero-content { position: relative; z-index: 2; }
        .hero-badge {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 8px 20px; background: white;
            border: 1px solid var(--border); border-radius: 50px;
            font-size: 13px; font-weight: 500; color: var(--text-secondary);
            margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        .hero-badge-dot { width: 6px; height: 6px; border-radius: 50%; background: #4DC9A8; animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .hero h1 {
            font-size: clamp(44px, 7vw, 80px); font-weight: 800;
            letter-spacing: -2px; line-height: 1.05; margin-bottom: 16px;
            color: #1E293B;
        }
        .hero h1 span {
            background: linear-gradient(135deg, #00D4FF, #5B8DEF, #9B59B6, #B829DD);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .hero p { font-size: clamp(17px,2.2vw,20px); color: var(--text-secondary); max-width: 500px; line-height: 1.6; margin: 0 auto 16px; }
        .hero-tap-hint { font-size: 13px; color: var(--text-tertiary); margin-bottom: 36px; animation: fadeInUp 1s ease 1.5s both; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .hero-buttons { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .btn-primary {
            display: inline-flex; align-items: center; gap: 10px;
            padding: 16px 32px; background: var(--gradient); border: none; border-radius: 16px;
            color: white; font-size: 16px; font-weight: 600; text-decoration: none;
            transition: transform 0.2s, box-shadow 0.2s; cursor: pointer;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 12px 40px rgba(91,141,239,0.35); }
        .btn-primary svg { width: 22px; height: 22px; }
        .btn-secondary {
            display: inline-flex; align-items: center; gap: 10px;
            padding: 16px 32px; background: white; border: 1px solid var(--border);
            border-radius: 16px; color: var(--text-primary); font-size: 16px; font-weight: 500;
            text-decoration: none; box-shadow: 0 2px 8px rgba(0,0,0,0.04); transition: all 0.2s;
        }
        .btn-secondary:hover { background: var(--bg-card-hover); border-color: var(--border-hover); transform: translateY(-2px); }

        .pop-counter {
            position: relative; z-index: 2; margin-top: 24px; padding-top: 16px;
            border-top: 1px solid rgba(0,0,0,0.06); text-align: center;
        }
        .pop-counter-value {
            font-size: 32px; font-weight: 800;
            background: var(--gradient); -webkit-background-clip: text;
            -webkit-text-fill-color: transparent; background-clip: text;
        }
        .pop-counter-value.bump { animation: counterBump 0.3s ease; }
        @keyframes counterBump { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
        .pop-counter-label { font-size: 13px; color: var(--text-tertiary); margin-top: 4px; font-weight: 500; }

        /* ═══════════════════════════════════════ */
        /* SECTIONS                               */
        /* ═══════════════════════════════════════ */
        section { position: relative; z-index: 1; padding: 80px 24px; }
        .section-container { max-width: 1200px; margin: 0 auto; }
        .section-label { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 1.5px; color: var(--blue); margin-bottom: 16px; }
        .section-title { font-size: clamp(32px,5vw,48px); font-weight: 800; letter-spacing: -1px; line-height: 1.15; margin-bottom: 20px; color: var(--text-primary); }
        .section-title span {
            background: linear-gradient(135deg, #00D4FF, #5B8DEF, #9B59B6, #B829DD);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .section-subtitle { font-size: 18px; color: var(--text-secondary); max-width: 600px; line-height: 1.6; }
        .section-header { text-align: center; margin-bottom: 48px; }
        .section-header .section-subtitle { margin: 0 auto; }

        .features-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
        .feature-card { padding: 32px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 20px; backdrop-filter: blur(20px); transition: all 0.3s; position: relative; overflow: hidden; box-shadow: 0 2px 12px rgba(0,0,0,0.04); }
        .feature-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, rgba(0,0,0,0.05), transparent); opacity: 0; transition: opacity 0.3s; }
        .feature-card:hover { background: var(--bg-card-hover); border-color: var(--border-hover); transform: translateY(-4px); }
        .feature-card:hover::before { opacity: 1; }
        .feature-icon { width: 48px; height: 48px; border-radius: 14px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; font-size: 22px; }
        .feature-card h3 { font-size: 18px; font-weight: 700; margin-bottom: 10px; }
        .feature-card p { font-size: 14px; color: var(--text-secondary); line-height: 1.6; }
        .fi-voice { background: rgba(0,212,255,0.12); } .fi-pop { background: rgba(77,201,168,0.12); }
        .fi-copop { background: rgba(155,89,182,0.12); } .fi-categories { background: rgba(255,209,102,0.12); }
        .fi-reminders { background: rgba(91,141,239,0.12); } .fi-stats { background: rgba(184,41,221,0.12); }
        .fi-checklist { background: rgba(76,175,80,0.12); } .fi-widget { background: rgba(255,142,83,0.12); }

        .how-it-works { background: linear-gradient(180deg, var(--bg-deep) 0%, #F0F4FF 50%, var(--bg-deep) 100%); }
        .steps { display: grid; grid-template-columns: repeat(3, 1fr); gap: 40px; position: relative; }
        .steps::before { content: ''; position: absolute; top: 90px; left: 15%; right: 15%; height: 2px; background: linear-gradient(90deg, var(--cyan), var(--blue), var(--purple)); opacity: 0.3; }
        .step { text-align: center; position: relative; }
        .step-number { width: 96px; height: 96px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 24px; font-size: 36px; font-weight: 800; background: white; border: 2px solid var(--border); position: relative; z-index: 1; box-shadow: 0 4px 16px rgba(0,0,0,0.06); color: var(--text-primary); }
        .step-number::after { content: ''; position: absolute; inset: -4px; border-radius: 50%; background: var(--gradient); opacity: 0.15; z-index: -1; }
        .step-video {
            width: 180px; height: 180px; border-radius: 50%; overflow: hidden;
            margin: 0 auto 24px; position: relative; z-index: 1;
            box-shadow: 0 8px 32px rgba(91,141,239,0.18), 0 2px 8px rgba(0,0,0,0.06);
        }
        .step-video::before {
            content: ''; position: absolute; inset: -3px; border-radius: 50%;
            background: var(--gradient); z-index: -1;
        }
        .step-video::after {
            content: ''; position: absolute; inset: 0; border-radius: 50%;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4); z-index: 2; pointer-events: none;
        }
        .step-video video {
            width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 50%;
        }
        .step h3 { font-size: 22px; font-weight: 700; margin-bottom: 10px; }
        .step p { font-size: 15px; color: var(--text-secondary); line-height: 1.6; max-width: 280px; margin: 0 auto; }

        .pro-section { background: #F8FAFC; }
        .pro-table-container { max-width: 800px; margin: 0 auto; background: white; border: 1px solid var(--border); border-radius: 24px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.06); }
        .pro-table { width: 100%; border-collapse: collapse; }
        .pro-table thead { background: #F8FAFC; }
        .pro-table th { padding: 20px 24px; text-align: left; font-size: 14px; font-weight: 600; color: var(--text-secondary); border-bottom: 1px solid var(--border); }
        .pro-table th:nth-child(2), .pro-table th:nth-child(3) { text-align: center; }
        .pro-table th.pro-header { background: linear-gradient(135deg, rgba(91,141,239,0.08), rgba(155,89,182,0.08)); color: var(--blue); }
        .pro-table td { padding: 16px 24px; font-size: 14px; color: var(--text-primary); border-bottom: 1px solid var(--border); }
        .pro-table td:nth-child(2), .pro-table td:nth-child(3) { text-align: center; font-weight: 500; }
        .pro-table tr:last-child td { border-bottom: none; }
        .check { color: #4DC9A8; font-size: 18px; } .cross { color: var(--text-tertiary); font-size: 18px; }
        .pro-cta { text-align: center; margin-top: 32px; }

        footer { position: relative; z-index: 1; padding: 48px 24px 32px; border-top: 1px solid var(--border); }
        .footer-container { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 40px; }
        .footer-brand { flex: 1; min-width: 200px; }
        .footer-brand .nav-logo { margin-bottom: 12px; display: inline-block; }
        .footer-brand p { font-size: 14px; color: var(--text-tertiary); line-height: 1.6; max-width: 280px; }
        .footer-links { display: flex; gap: 60px; }
        .footer-col h4 { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); margin-bottom: 16px; }
        .footer-col a { display: block; font-size: 14px; color: var(--text-tertiary); text-decoration: none; margin-bottom: 10px; transition: color 0.2s; }
        .footer-col a:hover { color: var(--text-primary); }
        .footer-bottom { max-width: 1200px; margin: 40px auto 0; padding-top: 20px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: var(--text-tertiary); }

        .fade-in { opacity: 0; transform: translateY(30px); transition: opacity 0.6s, transform 0.6s; }
        .fade-in.visible { opacity: 1; transform: translateY(0); }

        @media (max-width: 900px) {
            nav { padding: 16px 24px; } .nav-links { display: none; }
            .nav-hamburger { display: flex; }
            .features-grid { grid-template-columns: repeat(2, 1fr); }

            .steps { grid-template-columns: 1fr; gap: 48px; } .steps::before { display: none; }
            .footer-links { gap: 40px; }
        }
        @media (max-width: 600px) {
            .features-grid { grid-template-columns: 1fr; }
            .hero-buttons { flex-direction: column; width: 100%; }
            .btn-primary, .btn-secondary { width: 100%; justify-content: center; }
            .footer-container { flex-direction: column; } .footer-links { flex-direction: column; gap: 32px; }
            .footer-bottom { flex-direction: column; gap: 8px; text-align: center; }
            .pro-table th, .pro-table td { padding: 12px 16px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="bubbles-bg" id="bubblesBg"></div>

    <nav>
        <div class="nav-logo">Bubbl</div>
        <div class="nav-links">
            <a href="#features">Features</a>
            <a href="#how-it-works">How It Works</a>
            <a href="#plus">Bubbl+</a>
            <a href="https://apps.apple.com/app/id6758945006" class="nav-cta" target="_blank" rel="noopener">Download</a>
        </div>
        <div class="nav-hamburger" id="hamburger" onclick="toggleMenu()">
            <span></span><span></span><span></span>
        </div>
    </nav>
    <div class="mobile-menu" id="mobileMenu">
        <a href="#features" onclick="toggleMenu()">Features</a>
        <a href="#how-it-works" onclick="toggleMenu()">How It Works</a>
        <a href="#plus" onclick="toggleMenu()">Bubbl+</a>
        <a href="https://apps.apple.com/app/id6758945006" class="nav-cta" target="_blank" rel="noopener">Download</a>
    </div>

    <section class="hero">
        <div class="hero-glow"></div>
        <div class="bubble-canvas" id="heroCanvas"></div>
        <div class="hero-content">
            <div class="hero-badge"><span class="hero-badge-dot"></span> Available on iOS</div>
            <h1>Make doing life,<br><span>lighter.</span></h1>
            <p>Bubbl turns your tasks into floating bubbles. Create them with your voice, organise them visually, and pop them when they're done.</p>
            <div class="hero-buttons">
                <a href="https://apps.apple.com/app/id6758945006" class="btn-primary" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.8-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z"/></svg>
                    Download for iOS
                </a>
                <a href="#features" class="btn-secondary">Learn More</a>
            </div>
            <div class="pop-counter">
                <div class="pop-counter-value" id="popCounter">0</div>
                <div class="pop-counter-label">bubbles popped</div>
            </div>
        </div>
    </section>

    <section id="features">
        <div class="section-container">
            <div class="section-header fade-in">
                <div class="section-label">Features</div>
                <h2 class="section-title">Everything you need,<br>nothing you <span>don't</span></h2>
                <p class="section-subtitle">Bubbl keeps things simple. No complicated project boards, no overwhelming lists. Just bubbles.</p>
            </div>
            <div class="features-grid">
                <div class="feature-card fade-in"><div class="feature-icon fi-voice">&#127908;</div><h3>Voice Input</h3><p>Speak your thoughts and Bubbl creates a bubble for you. Smart transcription understands dates, lists, and priorities.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-pop">&#127881;</div><h3>Pop to Complete</h3><p>Done with a task? Pop the bubble. It's satisfying, it's visual, and it feels like clearing mental clutter.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-copop">&#129309;</div><h3>Co-Pop</h3><p>Share bubbles with your partner, housemate, or anyone you do life with. Tackle tasks together.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-checklist">&#9745;</div><h3>Checklists</h3><p>Add multi-item checklists inside any bubble. Track progress, attach photos, and tick things off as you go.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-categories">&#127912;</div><h3>Categories</h3><p>Colour-coded categories keep your bubbles organised. Personal, Work, Health, Ideas, and more.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-reminders">&#128276;</div><h3>Smart Reminders</h3><p>Set reminders on any bubble so nothing slips through the cracks. Bubbles grow as their due date approaches.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-widget">&#128241;</div><h3>Home Screen Widget</h3><p>See your bubbles at a glance without opening the app. Quick access to what matters right from your Home Screen.</p></div>
                <div class="feature-card fade-in"><div class="feature-icon fi-stats">&#128200;</div><h3>Statistics</h3><p>Track your productivity with bubble stats. See how many you've created, popped, and your current streak.</p></div>
            </div>
        </div>
    </section>

    <section class="how-it-works" id="how-it-works">
        <div class="section-container">
            <div class="section-header fade-in">
                <div class="section-label">How It Works</div>
                <h2 class="section-title">Simple by <span>design</span></h2>
                <p class="section-subtitle">Three steps. That's it.</p>
            </div>
            <div class="steps">
                <div class="step fade-in">
                    <div class="step-video"><video autoplay muted loop playsinline><source src="/videos/steps/step-1.mp4" type="video/mp4"></video></div>
                    <h3>Speak</h3><p>Say what's on your mind. Bubbl turns your voice into organised tasks with smart transcription.</p>
                </div>
                <div class="step fade-in">
                    <div class="step-video"><video autoplay muted loop playsinline><source src="/videos/steps/step-2.mp4" type="video/mp4"></video></div>
                    <h3>Share</h3><p>Send bubbles to your partner, housemate, or anyone you share life with. Tackle things together.</p>
                </div>
                <div class="step fade-in">
                    <div class="step-video"><video autoplay muted loop playsinline><source src="/videos/steps/step-3.mp4" type="video/mp4"></video></div>
                    <h3>Pop</h3><p>Done? Pop it. Watch it burst with a satisfying animation and keep your streak going.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="pro-section" id="plus">
        <div class="section-container">
            <div class="section-header fade-in">
                <div class="section-label">Bubbl+</div>
                <h2 class="section-title">Do more with <span>Bubbl+</span></h2>
                <p class="section-subtitle">Unlock the full experience with a free trial.</p>
            </div>
            <div class="pro-table-container fade-in">
                <table class="pro-table">
                    <thead><tr><th>Feature</th><th>Free</th><th class="pro-header">Bubbl+</th></tr></thead>
                    <tbody>
                        <tr><td>Voice Bubbles</td><td>2 / day</td><td>20 / day</td></tr>
                        <tr><td>Co-Pop Partners</td><td>1</td><td>Unlimited</td></tr>
                        <tr><td>Shared Bubbles</td><td>3 at once</td><td>Unlimited</td></tr>
                        <tr><td>Custom Categories</td><td><span class="cross">&#10005;</span></td><td><span class="check">&#10003;</span></td></tr>
                        <tr><td>Custom Backgrounds</td><td><span class="cross">&#10005;</span></td><td><span class="check">&#10003;</span></td></tr>
                        <tr><td>Bubble Canvas</td><td><span class="check">&#10003;</span></td><td><span class="check">&#10003;</span></td></tr>
                        <tr><td>Smart Reminders</td><td><span class="check">&#10003;</span></td><td><span class="check">&#10003;</span></td></tr>
                    </tbody>
                </table>
            </div>
            <div class="pro-cta fade-in"><a href="https://apps.apple.com/app/id6758945006" class="btn-primary" target="_blank" rel="noopener">Try Bubbl+ Free</a></div>
        </div>
    </section>

    <footer>
        <div class="footer-container">
            <div class="footer-brand"><div class="nav-logo">Bubbl</div><p>Do Life Lighter.</p></div>
            <div class="footer-links">
                <div class="footer-col"><h4>App</h4><a href="https://apps.apple.com/app/id6758945006" target="_blank" rel="noopener">Download</a><a href="#features">Features</a><a href="#plus">Bubbl+</a></div>
                <div class="footer-col"><h4>Legal</h4><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a></div>
                <div class="footer-col"><h4>Support</h4><a href="mailto:support@bubblapp.com">support@bubblapp.com</a></div>
            </div>
        </div>
        <div class="footer-bottom"><span>&copy; 2026 Bubbl. All rights reserved.</span></div>
    </footer>

    <script>
    // ═══════════════════════════════════════════════════
    // BUBBLE DATA WITH BADGES
    // ═══════════════════════════════════════════════════
    // Bubbles positioned around the edges to avoid hero content center
    const BUBBLES = [
        { label: 'Buy groceries', color: '#5B8DEF', size: 110, x: 3, y: 12 },
        { label: 'Call dentist', color: '#E056A0', size: 90, x: 82, y: 10 },
        { label: 'Finish report', color: '#9B59B6', size: 105, x: 5, y: 65 },
        { label: 'Gym', color: '#00D4FF', size: 75, x: 88, y: 60 },
        { label: 'Pick up parcel', color: '#FFD166', size: 95, x: 2, y: 38 },
        { label: 'Book flights', color: '#FF8E53', size: 88, x: 85, y: 35 },
        { label: 'Walk the dog', color: '#4DC9A8', size: 78, x: 75, y: 80 },
        { label: 'Meal prep', color: '#00B4D8', size: 72, x: 15, y: 82 },
        { label: 'Reply to Sam', color: '#E06B85', size: 85, x: 88, y: 82 },
        { label: 'Water plants', color: '#3EAF85', size: 70, x: 5, y: 82 },
    ];

    // Randomize badges on each bubble (matching app badge types)
    const DUE_OPTIONS = ['Overdue', 'Today', 'Tomorrow', '14 Feb', '20 Feb', '28 Feb'];
    const CHECKLIST_OPTIONS = [
        { done: 1, total: 3 }, { done: 2, total: 5 }, { done: 0, total: 4 },
        { done: 3, total: 6 }, { done: 1, total: 2 }, { done: 4, total: 4 },
    ];
    const PARTNER_NAMES = ['Jess', 'Tom', 'Mia', 'Alex', 'Lily'];

    // Assign random badges
    BUBBLES.forEach(b => {
        // ~60% chance of a due date
        if (Math.random() < 0.6) b.due = DUE_OPTIONS[Math.floor(Math.random() * DUE_OPTIONS.length)];
        // ~40% chance of a checklist
        if (Math.random() < 0.4) {
            const cl = CHECKLIST_OPTIONS[Math.floor(Math.random() * CHECKLIST_OPTIONS.length)];
            b.checklist = cl;
        }
        // ~30% chance of a partner (tagged) — shown top-left
        // ~25% chance of a sender (received) — shown bottom-left
        // Mutually exclusive: a bubble is either yours with a tagged partner, or received from a sender
        const shareRoll = Math.random();
        if (shareRoll < 0.3) {
            b.taggedPartner = PARTNER_NAMES[Math.floor(Math.random() * PARTNER_NAMES.length)];
        } else if (shareRoll < 0.55) {
            b.sender = PARTNER_NAMES[Math.floor(Math.random() * PARTNER_NAMES.length)];
        }
    });

    const canvas = document.getElementById('heroCanvas');
    let popCount = 0;
    let audioCtx = null;
    const HOLD_DURATION = 700; // ms

    // ═══════════════════════════════════════════════════
    // PHYSICS CONSTANTS (matching iOS app)
    // ═══════════════════════════════════════════════════
    const PHYSICS = {
        friction: 0.82,              // Per-frame velocity damping
        bounceDamping: 0.25,         // Wall bounce energy loss
        collisionDamping: 0.2,       // Bubble-bubble collision energy loss
        restitution: 0.4,            // Bounciness coefficient
        collisionImpulseScale: 0.3,  // How strong collision response is
        separationStrength: 1.0,     // Overlap push-apart strength
        anchorReturnStrength: 0.15,  // Pull back to home position
        orbitRadius: 3.0,             // Gentle visible float motion
        orbitSpeed: 0.008,           // Breathing speed (radians/frame)
        randomDriftStrength: 0.008,  // Organic micro-drift
        maxVelocity: 0.8,            // Speed cap
        dragThrowMultiplier: 0.12,   // Gentle throw on release
        squishAmount: 0.12,          // Visual deformation on collision
        squishStiffness: 0.15,       // Spring-back speed
        squishDamping: 0.85,         // Smooth deformation recovery
    };

    // Track all active bubbles for physics
    const bubbleStates = [];

    // ═══════════════════════════════════════════════════
    // POP SOUND (Web Audio synthesis matching app)
    // ═══════════════════════════════════════════════════
    function playPopSound() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t = audioCtx.currentTime;

        // Pop burst - noise
        const noiseLen = 0.04;
        const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * noiseLen, audioCtx.sampleRate);
        const noiseData = noiseBuf.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) noiseData[i] = (Math.random() * 2 - 1) * Math.max(0, 1 - i / (noiseData.length * 0.3));
        const noiseSrc = audioCtx.createBufferSource();
        noiseSrc.buffer = noiseBuf;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.25, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + noiseLen);
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'bandpass'; noiseFilter.frequency.value = 2000; noiseFilter.Q.value = 1;
        noiseSrc.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
        noiseSrc.start(t); noiseSrc.stop(t + noiseLen);

        // Descending "plop" tone
        const osc1 = audioCtx.createOscillator();
        const gain1 = audioCtx.createGain();
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(900, t);
        osc1.frequency.exponentialRampToValueAtTime(180, t + 0.08);
        gain1.gain.setValueAtTime(0.3, t);
        gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc1.connect(gain1); gain1.connect(audioCtx.destination);
        osc1.start(t); osc1.stop(t + 0.12);

        // Sub thump
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(100, t);
        gain2.gain.setValueAtTime(0.2, t);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc2.connect(gain2); gain2.connect(audioCtx.destination);
        osc2.start(t); osc2.stop(t + 0.08);

        // Shimmer overtone
        const osc3 = audioCtx.createOscillator();
        const gain3 = audioCtx.createGain();
        osc3.type = 'sine';
        osc3.frequency.setValueAtTime(1800, t);
        osc3.frequency.exponentialRampToValueAtTime(600, t + 0.12);
        gain3.gain.setValueAtTime(0.08, t);
        gain3.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        osc3.connect(gain3); gain3.connect(audioCtx.destination);
        osc3.start(t); osc3.stop(t + 0.18);
    }

    // ═══════════════════════════════════════════════════
    // CREATE BUBBLE
    // ═══════════════════════════════════════════════════
    function createBubble(data, index, poppable) {
        const el = document.createElement('div');
        el.className = 'glossy-bubble' + (poppable ? '' : ' static-bubble');
        el.style.width = data.size + 'px';
        el.style.height = data.size + 'px';

        // Convert percentage to pixel position
        const canvasRect = canvas.getBoundingClientRect();
        const px = (data.x / 100) * canvasRect.width;
        const py = (data.y / 100) * canvasRect.height;

        el.style.left = px + 'px';
        el.style.top = py + 'px';
        el.style.opacity = '0';
        setTimeout(() => { el.style.opacity = '1'; el.style.transition = 'opacity 0.5s'; }, 150 + index * 120);

        // Scale font to fit inside bubble — shorter labels get bigger text
        const textLen = data.label.length;
        let fontSize;
        if (textLen <= 4) fontSize = data.size / 5.5;        // "Gym" → large
        else if (textLen <= 10) fontSize = data.size / 7;    // "Meal prep" → medium
        else if (textLen <= 15) fontSize = data.size / 8;    // "Buy groceries" → standard
        else fontSize = data.size / 9;                        // "Pick up parcel" → smaller
        fontSize = Math.max(10, Math.min(18, fontSize));
        const radius = data.size / 2;

        // Physics state for this bubble
        const state = {
            el: el,
            data: data,
            x: px,
            y: py,
            vx: 0,
            vy: 0,
            radius: radius,
            mass: radius * radius * 0.01,
            anchorX: px,
            anchorY: py,
            orbitAngle: Math.random() * Math.PI * 2,
            orbitSpeedMult: 0.7 + Math.random() * 0.6,
            squishX: 1,
            squishY: 1,
            squishVX: 0,
            squishVY: 0,
            isDragging: false,
            poppable: poppable,
            popping: false,
            index: index,
        };

        // Build badges HTML — positioned on circumference like iOS app
        let badgesHTML = '';
        const r = radius;
        const badgeScale = Math.min(1.4, Math.max(0.8, data.size / 100));

        // Due date badge: above bubble, centered, offset by radius + 8
        if (data.due) {
            let dueClass = 'future';
            let icon = '';
            if (data.due === 'Overdue') { dueClass = 'overdue'; icon = '⚠ '; }
            else if (data.due === 'Today') { dueClass = 'today'; icon = '⏱ '; }
            else if (data.due === 'Tomorrow') dueClass = 'tomorrow';
            const dueTop = -(8 * badgeScale);
            badgesHTML += `<div class="bubble-badge badge-due ${dueClass}" style="top:${dueTop}px;font-size:${Math.round(9 * badgeScale)}px;">${icon}${data.due}</div>`;
        }

        // Checklist badge: bottom-right at 45° on circumference
        if (data.checklist) {
            const angle = Math.PI / 4; // 45 degrees
            const cx = r + Math.cos(angle) * r;
            const cy = r + Math.sin(angle) * r;
            const isComplete = data.checklist.done === data.checklist.total;
            const clsExtra = isComplete ? ' complete' : '';
            const sz = Math.round(9 * badgeScale);
            badgesHTML += `<div class="bubble-badge badge-checklist${clsExtra}" style="left:${cx}px;top:${cy}px;transform:translate(-50%,-50%);font-size:${sz}px;">&#9745; ${data.checklist.done}/${data.checklist.total}</div>`;
        }

        // Tagged partner avatar: top-left at -135° on circumference
        if (data.taggedPartner) {
            const angle = -Math.PI * 3 / 4; // -135 degrees (top-left)
            const cx = r + Math.cos(angle) * r;
            const cy = r + Math.sin(angle) * r;
            const avSize = Math.round(22 * badgeScale);
            const initial = data.taggedPartner[0];
            const fs = Math.round(avSize * 0.4);
            badgesHTML += `<div class="bubble-badge badge-avatar" style="left:${cx}px;top:${cy}px;width:${avSize}px;height:${avSize}px;transform:translate(-50%,-50%);font-size:${fs}px;">${initial}</div>`;
        }

        // Sender avatar: bottom-left at 135° on circumference
        if (data.sender) {
            const angle = Math.PI * 3 / 4; // 135 degrees (bottom-left)
            const cx = r + Math.cos(angle) * r;
            const cy = r + Math.sin(angle) * r;
            const avSize = Math.round(24 * badgeScale);
            const initial = data.sender[0];
            const fs = Math.round(avSize * 0.4);
            badgesHTML += `<div class="bubble-badge badge-avatar" style="left:${cx}px;top:${cy}px;width:${avSize}px;height:${avSize}px;transform:translate(-50%,-50%);font-size:${fs}px;">${initial}</div>`;
        }

        // Progress ring SVG
        const ringR = (data.size + 6) / 2 - 3;
        const circ = 2 * Math.PI * ringR;

        el.innerHTML = `
            <svg class="pop-ring" width="${data.size + 6}" height="${data.size + 6}" viewBox="0 0 ${data.size + 6} ${data.size + 6}">
                <circle cx="${(data.size + 6) / 2}" cy="${(data.size + 6) / 2}" r="${ringR}"
                    stroke-dasharray="${circ}" stroke-dashoffset="${circ}" />
            </svg>
            <div class="bubble-sphere">
                <div class="bubble-base" style="background: radial-gradient(circle at 35% 35%, ${lighten(data.color, 30)}, ${data.color} 60%, ${darken(data.color, 20)} 100%);"></div>
                <div class="bubble-highlight"></div>
                <div class="bubble-highlight-2"></div>
                <div class="bubble-rim"></div>
                <div class="bubble-glow" style="background:${data.color};"></div>
                <div class="bubble-label" style="font-size:${fontSize}px;">${data.label}</div>
            </div>
            ${badgesHTML}
        `;

        // ── DRAG + HOLD LOGIC ──
        let startX, startY, origX, origY, dragMoved = false;
        let holdTimer = null;
        let lastDragX = 0, lastDragY = 0, prevDragX = 0, prevDragY = 0;

        function getPos(e) {
            const p = e.touches ? e.touches[0] : e;
            return { x: p.clientX, y: p.clientY };
        }

        function startHold() {
            if (!poppable) return;
            const circle = el.querySelector('.pop-ring circle');
            circle.style.transition = `stroke-dashoffset ${HOLD_DURATION}ms linear`;
            circle.style.strokeDashoffset = '0';
            holdTimer = setTimeout(() => {
                if (!dragMoved) popBubble(state);
            }, HOLD_DURATION);
        }

        function cancelHold() {
            clearTimeout(holdTimer);
            holdTimer = null;
            const circle = el.querySelector('.pop-ring circle');
            if (circle) {
                circle.style.transition = 'stroke-dashoffset 0.2s';
                const ringR = (data.size + 6) / 2 - 3;
                circle.style.strokeDashoffset = (2 * Math.PI * ringR) + '';
            }
        }

        function onDown(e) {
            if (state.popping) return;
            e.preventDefault();
            const p = getPos(e);
            startX = p.x; startY = p.y;
            origX = state.x; origY = state.y;
            state.isDragging = true;
            dragMoved = false;
            lastDragX = p.x; lastDragY = p.y;
            prevDragX = p.x; prevDragY = p.y;
            el.style.zIndex = '10';
            // Only start hold-to-pop for poppable bubbles
            if (poppable) startHold();
        }

        function onMove(e) {
            if (!state.isDragging) return;
            e.preventDefault();
            const p = getPos(e);
            const dx = p.x - startX, dy = p.y - startY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                dragMoved = true;
                cancelHold();
            }
            const cr = canvas.getBoundingClientRect();
            let nx = origX + dx, ny = origY + dy;
            nx = Math.max(5, Math.min(cr.width - data.size - 5, nx));
            ny = Math.max(15, Math.min(cr.height - data.size - 10, ny));
            state.x = nx;
            state.y = ny;

            // Apply obstacle collision during drag so bubble slides along edge
            const obstRect = getObstacleRect();
            const bcx = state.x + state.radius;
            const bcy = state.y + state.radius;
            const nearX = Math.max(obstRect.left, Math.min(bcx, obstRect.right));
            const nearY = Math.max(obstRect.top, Math.min(bcy, obstRect.bottom));
            const ddx = bcx - nearX, ddy = bcy - nearY;
            const dd = Math.sqrt(ddx * ddx + ddy * ddy);
            if (dd < state.radius && dd > 0.001) {
                const ovl = state.radius - dd;
                state.x += (ddx / dd) * (ovl + 2);
                state.y += (ddy / dd) * (ovl + 2);
            } else if (dd === 0) {
                // Center inside obstacle, push to nearest edge
                const dL = bcx - obstRect.left, dR = obstRect.right - bcx;
                const dT = bcy - obstRect.top, dB = obstRect.bottom - bcy;
                const mn = Math.min(dL, dR, dT, dB);
                if (mn === dL) state.x -= dL + state.radius + 2;
                else if (mn === dR) state.x += dR + state.radius + 2;
                else if (mn === dT) state.y -= dT + state.radius + 2;
                else state.y += dB + state.radius + 2;
            }

            // Track velocity for throw
            prevDragX = lastDragX; prevDragY = lastDragY;
            lastDragX = p.x; lastDragY = p.y;
        }

        function onUp(e) {
            if (!state.isDragging) return;
            state.isDragging = false;
            el.style.zIndex = '5';
            if (dragMoved) {
                cancelHold();
                // Apply gentle throw velocity
                const throwVx = (lastDragX - prevDragX) * PHYSICS.dragThrowMultiplier;
                const throwVy = (lastDragY - prevDragY) * PHYSICS.dragThrowMultiplier;
                const speed = Math.sqrt(throwVx * throwVx + throwVy * throwVy);
                if (speed > PHYSICS.maxVelocity) {
                    const sc = PHYSICS.maxVelocity / speed;
                    state.vx = throwVx * sc;
                    state.vy = throwVy * sc;
                } else {
                    state.vx = throwVx;
                    state.vy = throwVy;
                }
            }
            // Always update anchor to current position (prevents snapping back)
            state.anchorX = state.x;
            state.anchorY = state.y;
        }

        el.addEventListener('mousedown', onDown);
        el.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);

        canvas.appendChild(el);
        bubbleStates.push(state);
        return state;
    }

    // ═══════════════════════════════════════════════════
    // OBSTACLE COLLISION (hero content elements)
    // ═══════════════════════════════════════════════════
    const heroContent = document.querySelector('.hero-content');

    // Get hero-content as a rectangular obstacle relative to canvas
    function getObstacleRect() {
        const cr = canvas.getBoundingClientRect();
        const hr = heroContent.getBoundingClientRect();
        const padding = 10; // Extra buffer so bubbles don't touch text
        return {
            left: hr.left - cr.left - padding,
            top: hr.top - cr.top - padding,
            right: hr.right - cr.left + padding,
            bottom: hr.bottom - cr.top + padding,
        };
    }

    // Resolve circle vs axis-aligned rectangle collision
    function resolveCircleRect(s, rect) {
        // Bubble center
        const cx = s.x + s.radius;
        const cy = s.y + s.radius;

        // Find closest point on rectangle to circle center
        const nearestX = Math.max(rect.left, Math.min(cx, rect.right));
        const nearestY = Math.max(rect.top, Math.min(cy, rect.bottom));

        const dx = cx - nearestX;
        const dy = cy - nearestY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < s.radius && dist > 0.001) {
            // Push bubble out
            const overlap = s.radius - dist;
            const nx = dx / dist;
            const ny = dy / dist;
            const sepAmount = overlap + 2.0;

            s.x += nx * sepAmount;
            s.y += ny * sepAmount;

            // Bounce velocity (soft, like obstacle collision in app)
            const velAlongNormal = s.vx * nx + s.vy * ny;
            if (velAlongNormal < 0) {
                s.vx -= (1 + 0.3) * velAlongNormal * nx * 0.5;
                s.vy -= (1 + 0.3) * velAlongNormal * ny * 0.5;
            }

            // Update anchor to prevent vibration
            s.anchorX += nx * sepAmount * 0.5;
            s.anchorY += ny * sepAmount * 0.5;

            // Squish
            const impactStrength = Math.min(1, overlap / 5);
            s.squishX = 1.0 + PHYSICS.squishAmount * impactStrength;
            s.squishY = 1.0 - PHYSICS.squishAmount * impactStrength * 0.6;
        } else if (dist === 0) {
            // Circle center is inside rectangle — push out to nearest edge
            const distToLeft = cx - rect.left;
            const distToRight = rect.right - cx;
            const distToTop = cy - rect.top;
            const distToBottom = rect.bottom - cy;
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);

            let pushX = 0, pushY = 0;
            if (minDist === distToLeft) pushX = -(distToLeft + s.radius + 2);
            else if (minDist === distToRight) pushX = distToRight + s.radius + 2;
            else if (minDist === distToTop) pushY = -(distToTop + s.radius + 2);
            else pushY = distToBottom + s.radius + 2;

            s.x += pushX;
            s.y += pushY;
            s.anchorX += pushX * 0.5;
            s.anchorY += pushY * 0.5;
            s.vx *= -0.3;
            s.vy *= -0.3;
        }
    }

    // ═══════════════════════════════════════════════════
    // PHYSICS ENGINE (60fps loop)
    // ═══════════════════════════════════════════════════
    function physicsStep() {
        const canvasRect = canvas.getBoundingClientRect();
        const cw = canvasRect.width;
        const ch = canvasRect.height;
        const obstacleRect = getObstacleRect();

        for (let i = 0; i < bubbleStates.length; i++) {
            const s = bubbleStates[i];
            if (s.isDragging || s.popping) continue;

            // ── Orbit / breathing motion around anchor ──
            s.orbitAngle += PHYSICS.orbitSpeed * s.orbitSpeedMult;
            const orbitX = Math.cos(s.orbitAngle) * PHYSICS.orbitRadius;
            const orbitY = Math.sin(s.orbitAngle) * PHYSICS.orbitRadius;

            // ── Anchor return force (gentle pull to home) ──
            const targetX = s.anchorX + orbitX;
            const targetY = s.anchorY + orbitY;
            const returnDx = targetX - s.x;
            const returnDy = targetY - s.y;
            s.vx += returnDx * PHYSICS.anchorReturnStrength;
            s.vy += returnDy * PHYSICS.anchorReturnStrength;

            // ── Random micro-drift for organic feel ──
            s.vx += (Math.random() - 0.5) * PHYSICS.randomDriftStrength;
            s.vy += (Math.random() - 0.5) * PHYSICS.randomDriftStrength;

            // ── Friction ──
            s.vx *= PHYSICS.friction;
            s.vy *= PHYSICS.friction;

            // ── Velocity cap ──
            const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
            if (speed > PHYSICS.maxVelocity) {
                s.vx = (s.vx / speed) * PHYSICS.maxVelocity;
                s.vy = (s.vy / speed) * PHYSICS.maxVelocity;
            }

            // ── Update position ──
            s.x += s.vx;
            s.y += s.vy;

            // ── Boundary collisions (padded to prevent badge clipping) ──
            const padTop = 15;   // space for due-date badge above
            const padBot = 10;   // space for checklist/avatar badge below
            const padX = 5;      // small side buffer
            if (s.x < padX) {
                s.x = padX;
                s.vx = Math.abs(s.vx) * PHYSICS.bounceDamping * 0.3;
                s.anchorX = Math.max(padX + s.radius * 0.5, s.anchorX);
            }
            if (s.x > cw - s.data.size - padX) {
                s.x = cw - s.data.size - padX;
                s.vx = -Math.abs(s.vx) * PHYSICS.bounceDamping * 0.3;
                s.anchorX = Math.min(cw - s.radius * 0.5 - padX, s.anchorX);
            }
            if (s.y < padTop) {
                s.y = padTop;
                s.vy = Math.abs(s.vy) * PHYSICS.bounceDamping * 0.3;
                s.anchorY = Math.max(padTop + s.radius * 0.5, s.anchorY);
            }
            if (s.y > ch - s.data.size - padBot) {
                s.y = ch - s.data.size - padBot;
                s.vy = -Math.abs(s.vy) * PHYSICS.bounceDamping * 0.3;
                s.anchorY = Math.min(ch - s.radius * 0.5 - padBot, s.anchorY);
            }

            // ── Hero content obstacle collision ──
            resolveCircleRect(s, obstacleRect);

            // ── Squish spring-back ──
            const squishDx = 1.0 - s.squishX;
            const squishDy = 1.0 - s.squishY;
            s.squishVX += squishDx * PHYSICS.squishStiffness;
            s.squishVY += squishDy * PHYSICS.squishStiffness;
            s.squishVX *= PHYSICS.squishDamping;
            s.squishVY *= PHYSICS.squishDamping;
            s.squishX += s.squishVX;
            s.squishY += s.squishVY;
        }

        // ── Bubble-to-bubble collisions ──
        for (let i = 0; i < bubbleStates.length; i++) {
            for (let j = i + 1; j < bubbleStates.length; j++) {
                const a = bubbleStates[i];
                const b = bubbleStates[j];
                if (a.popping || b.popping) continue;

                // Center positions
                const ax = a.x + a.radius;
                const ay = a.y + a.radius;
                const bx = b.x + b.radius;
                const by = b.y + b.radius;

                const dx = bx - ax;
                const dy = by - ay;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = a.radius + b.radius;

                if (dist < minDist && dist > 0.001) {
                    // Collision normal
                    const nx = dx / dist;
                    const ny = dy / dist;

                    // ── Separation (push apart) ──
                    const overlap = minDist - dist;
                    const sepAmount = overlap * PHYSICS.separationStrength + 2.0;
                    const totalMass = a.mass + b.mass;
                    const aRatio = b.mass / totalMass;
                    const bRatio = a.mass / totalMass;

                    if (!a.isDragging) {
                        a.x -= nx * sepAmount * aRatio;
                        a.y -= ny * sepAmount * aRatio;
                        a.anchorX -= nx * sepAmount * aRatio * 0.5;
                        a.anchorY -= ny * sepAmount * aRatio * 0.5;
                    }
                    if (!b.isDragging) {
                        b.x += nx * sepAmount * bRatio;
                        b.y += ny * sepAmount * bRatio;
                        b.anchorX += nx * sepAmount * bRatio * 0.5;
                        b.anchorY += ny * sepAmount * bRatio * 0.5;
                    }

                    // ── Impulse-based bounce ──
                    const relVx = b.vx - a.vx;
                    const relVy = b.vy - a.vy;
                    const relVelAlongNormal = relVx * nx + relVy * ny;

                    // Only resolve if moving toward each other
                    if (relVelAlongNormal < 0) {
                        const impulse = (1 + PHYSICS.restitution) * relVelAlongNormal / (1 / a.mass + 1 / b.mass);
                        const impulseX = impulse * nx * PHYSICS.collisionImpulseScale;
                        const impulseY = impulse * ny * PHYSICS.collisionImpulseScale;

                        if (!a.isDragging) {
                            a.vx += impulseX / a.mass;
                            a.vy += impulseY / a.mass;
                        }
                        if (!b.isDragging) {
                            b.vx -= impulseX / b.mass;
                            b.vy -= impulseY / b.mass;
                        }
                    }

                    // ── Visual squish on collision ──
                    const impactStrength = Math.min(1, overlap / 5);
                    if (!a.isDragging) {
                        a.squishX = 1.0 + PHYSICS.squishAmount * impactStrength;
                        a.squishY = 1.0 - PHYSICS.squishAmount * impactStrength * 0.6;
                    }
                    if (!b.isDragging) {
                        b.squishX = 1.0 + PHYSICS.squishAmount * impactStrength;
                        b.squishY = 1.0 - PHYSICS.squishAmount * impactStrength * 0.6;
                    }
                }
            }
        }

        // ── Apply positions to DOM ──
        for (let i = 0; i < bubbleStates.length; i++) {
            const s = bubbleStates[i];
            if (s.popping) continue;
            s.el.style.left = s.x + 'px';
            s.el.style.top = s.y + 'px';
            // Apply squish transform
            const sx = s.squishX.toFixed(3);
            const sy = s.squishY.toFixed(3);
            if (Math.abs(s.squishX - 1) > 0.002 || Math.abs(s.squishY - 1) > 0.002) {
                s.el.style.transform = `scale(${sx}, ${sy})`;
            } else {
                s.el.style.transform = '';
            }
        }

        requestAnimationFrame(physicsStep);
    }

    // ═══════════════════════════════════════════════════
    // POP BUBBLE
    // ═══════════════════════════════════════════════════
    function popBubble(state) {
        if (state.popping) return;
        state.popping = true;
        state.el.classList.add('popping');
        playPopSound();

        const cx = state.x + state.radius;
        const cy = state.y + state.radius;

        // Push nearby bubbles away (collision shockwave)
        for (let i = 0; i < bubbleStates.length; i++) {
            const other = bubbleStates[i];
            if (other === state || other.popping || other.isDragging) continue;
            const ox = other.x + other.radius;
            const oy = other.y + other.radius;
            const dx = ox - cx;
            const dy = oy - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < state.radius * 3 && dist > 0.001) {
                const force = (1 - dist / (state.radius * 3)) * 0.5;
                other.vx += (dx / dist) * force;
                other.vy += (dy / dist) * force;
            }
        }

        // Particles
        for (let i = 0; i < 14; i++) {
            const p = document.createElement('div');
            p.className = 'pop-particle';
            const a = (Math.PI * 2 / 14) * i + Math.random() * 0.4;
            const d = 50 + Math.random() * 90;
            const sz = 4 + Math.random() * 8;
            p.style.cssText = `left:${cx}px;top:${cy}px;width:${sz}px;height:${sz}px;background:${state.data.color};--tx:${Math.cos(a)*d}px;--ty:${Math.sin(a)*d - 25}px;`;
            canvas.appendChild(p); setTimeout(() => p.remove(), 600);
        }
        for (let i = 0; i < 10; i++) {
            const sp = document.createElement('div');
            sp.className = 'pop-sparkle';
            const a = Math.random() * Math.PI * 2;
            const d = 40 + Math.random() * 110;
            sp.style.cssText = `left:${cx}px;top:${cy}px;--tx:${Math.cos(a)*d}px;--ty:${Math.sin(a)*d - 20}px;`;
            canvas.appendChild(sp); setTimeout(() => sp.remove(), 500);
        }
        for (let i = 0; i < 2; i++) {
            const rp = document.createElement('div');
            rp.className = 'pop-ripple';
            const rSz = state.data.size * 0.6;
            rp.style.cssText = `left:${cx - rSz/2}px;top:${cy - rSz/2}px;width:${rSz}px;height:${rSz}px;animation-delay:${i*0.1}s;border-color:${state.data.color}55;`;
            canvas.appendChild(rp); setTimeout(() => rp.remove(), 700);
        }

        popCount++;
        const counter = document.getElementById('popCounter');
        counter.textContent = popCount;
        counter.classList.remove('bump');
        void counter.offsetWidth;
        counter.classList.add('bump');

        // Remove from physics and respawn as fully poppable (on repeat)
        setTimeout(() => {
            state.el.remove();
            const idx = bubbleStates.indexOf(state);
            if (idx > -1) bubbleStates.splice(idx, 1);

            // Respawn with new random position (within safe padded zone)
            const newData = { ...state.data,
                x: 5 + Math.random() * 80,
                y: 8 + Math.random() * 70,
            };
            // Re-randomize badges for the respawned bubble
            delete newData.due; delete newData.checklist;
            delete newData.taggedPartner; delete newData.sender;
            if (Math.random() < 0.6) newData.due = DUE_OPTIONS[Math.floor(Math.random() * DUE_OPTIONS.length)];
            if (Math.random() < 0.4) newData.checklist = CHECKLIST_OPTIONS[Math.floor(Math.random() * CHECKLIST_OPTIONS.length)];
            const shareRoll = Math.random();
            if (shareRoll < 0.3) newData.taggedPartner = PARTNER_NAMES[Math.floor(Math.random() * PARTNER_NAMES.length)];
            else if (shareRoll < 0.55) newData.sender = PARTNER_NAMES[Math.floor(Math.random() * PARTNER_NAMES.length)];

            createBubble(newData, Math.floor(Math.random() * 3), true);
        }, 1000 + Math.random() * 500);
    }

    // Color helpers
    function lighten(hex, pct) {
        const n = parseInt(hex.replace('#',''), 16);
        const r = Math.min(255, (n >> 16) + Math.round(255 * pct / 100));
        const g = Math.min(255, ((n >> 8) & 0xFF) + Math.round(255 * pct / 100));
        const b = Math.min(255, (n & 0xFF) + Math.round(255 * pct / 100));
        return `rgb(${r},${g},${b})`;
    }
    function darken(hex, pct) {
        const n = parseInt(hex.replace('#',''), 16);
        const r = Math.max(0, (n >> 16) - Math.round(255 * pct / 100));
        const g = Math.max(0, ((n >> 8) & 0xFF) - Math.round(255 * pct / 100));
        const b = Math.max(0, (n & 0xFF) - Math.round(255 * pct / 100));
        return `rgb(${r},${g},${b})`;
    }

    // ═══════════════════════════════════════════════════
    // HANDLE CANVAS RESIZE
    // ═══════════════════════════════════════════════════
    let lastCanvasWidth = 0, lastCanvasHeight = 0;
    function handleResize() {
        const cr = canvas.getBoundingClientRect();
        if (lastCanvasWidth === 0) {
            lastCanvasWidth = cr.width;
            lastCanvasHeight = cr.height;
            return;
        }
        const scaleX = cr.width / lastCanvasWidth;
        const scaleY = cr.height / lastCanvasHeight;
        for (const s of bubbleStates) {
            s.x *= scaleX;
            s.y *= scaleY;
            s.anchorX *= scaleX;
            s.anchorY *= scaleY;
        }
        lastCanvasWidth = cr.width;
        lastCanvasHeight = cr.height;
    }
    window.addEventListener('resize', handleResize);

    // Init bubbles
    BUBBLES.forEach((d, i) => createBubble(d, i, true));

    // Store initial canvas size and start physics
    const initRect = canvas.getBoundingClientRect();
    lastCanvasWidth = initRect.width;
    lastCanvasHeight = initRect.height;
    requestAnimationFrame(physicsStep);

    // Background bubbles (decorative, no physics)
    (function() {
        const c = document.getElementById('bubblesBg');
        const cols = ['rgba(0,212,255,0.08)', 'rgba(91,141,239,0.08)', 'rgba(155,89,182,0.06)', 'rgba(184,41,221,0.05)'];
        for (let i = 0; i < 10; i++) {
            const b = document.createElement('div');
            b.className = 'bubble-particle-bg';
            const sz = 30 + Math.random() * 50;
            b.style.cssText = `width:${sz}px;height:${sz}px;left:${Math.random()*100}%;background:radial-gradient(circle at 30% 30%, ${cols[i%cols.length]}, transparent 70%);border:1px solid rgba(0,0,0,0.03);animation-duration:${18+Math.random()*15}s;animation-delay:${Math.random()*15}s;--drift:${(Math.random()-0.5)*150}px;`;
            c.appendChild(b);
        }
    })();

    // Scroll animations
    const obs = new IntersectionObserver((entries) => {
        entries.forEach((e, i) => { if (e.isIntersecting) { setTimeout(() => e.target.classList.add('visible'), i * 80); obs.unobserve(e.target); } });
    }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });
    document.querySelectorAll('.fade-in').forEach(el => obs.observe(el));

    // Mobile menu toggle
    function toggleMenu() {
        document.getElementById('hamburger').classList.toggle('open');
        document.getElementById('mobileMenu').classList.toggle('open');
        document.body.style.overflow = document.getElementById('mobileMenu').classList.contains('open') ? 'hidden' : '';
    }
    // Make toggleMenu global
    window.toggleMenu = toggleMenu;

    // Smooth scroll
    document.querySelectorAll('a[href^="#"]').forEach(a => {
        a.addEventListener('click', function(e) { e.preventDefault(); const t = document.querySelector(this.getAttribute('href')); if (t) t.scrollIntoView({ behavior: 'smooth', block: 'start' }); });
    });
    </script>
</body>
</html>
